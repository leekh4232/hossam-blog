---
title: Node.js 기본 내장 모듈
description: "Node.js를 시작하는데 필수적으로 알아야 하는 기본 내장모듈에 대해 설명합니다."
categories: [06.Backend,Node]
date:   2025-08-27 09:00:00 +0900
author: Hossam
image: /images/indexs/node1.png
tags: [Web Development,Backend,Node]
pin: true
math: true
mermaid: true
---

# Node.js 기본 내장 모듈

## 1. path 모듈

`path` 모듈은 파일 및 디렉토리 경로 작업을 위한 유틸리티를 제공합니다. 운영 체제마다 경로 구분자가 다르기 때문에(Windows는 `\`, POSIX는 `/`) `path` 모듈을 사용하여 애플리케이션이 실행되는 환경에 관계없이 일관된 경로 처리를 보장하는 것이 중요합니다.

### 주요 기능

- **경로 조합**: `path.join()`을 사용하여 여러 경로 세그먼트를 결합할 수 있습니다. `../`와 같은 상대 경로도 올바르게 처리합니다.
- **경로 분석**: `path.dirname()`, `path.basename()`, `path.extname()`을 사용하여 경로에서 디렉토리 이름, 파일 이름, 확장자를 각각 추출할 수 있습니다.
- **경로 파싱**: `path.parse()`는 경로 문자열을 `root`, `dir`, `base`, `ext`, `name` 속성을 포함하는 객체로 변환하여 경로의 각 구성 요소를 쉽게 다룰 수 있게 해줍니다.

### 실습: path 모듈 사용하기

**실습: /01-기본모듈/01_path_modules.js**

```js
/** (1) 모듈참조 */
import path from 'path';

/** (2) 디렉토리명과 파일명 합치기 */
const currentPath = path.join('/Users/hello/world', '../photo.jpg');
console.log('파일 패스 : %s', currentPath);
console.log();

/** (3) 경로에서 디렉토리, 파일명, 확장자 구분하기 */
const dirname = path.dirname(currentPath);
const basename = path.basename(currentPath);
const extname = path.extname(currentPath);
console.log('디렉토리 : %s', dirname);
console.log('파일 이름 : %s', basename);
console.log('확장자 : %s', extname);
console.log();

/** (4) 경로정보 파싱 */
const parse = path.parse(currentPath);
console.log("root: " + parse.root);
console.log("dir: " + parse.dir);
console.log("name: " + parse.name);
console.log("ext: " + parse.ext);
console.log();
```

---

## 2. url 모듈

`url` 모듈은 URL 문자열의 구문 분석 및 분석을 위한 유틸리티를 제공합니다. 웹 애플리케이션 개발 시 클라이언트 요청의 URL을 해석하거나, API 요청을 위한 URL을 생성할 때 매우 유용합니다. WHATWG URL 표준을 따르는 `URL` 클래스를 사용하는 것이 권장됩니다.

### 주요 기능

- **URL 파싱**: `new URL()` 생성자는 URL 문자열을 입력받아 각 구성요소( `protocol`, `hostname`, `port`, `pathname`, `search`, `hash` 등)가 속성으로 포함된 `URL` 객체를 반환합니다.
- **QueryString 처리**: `URL` 객체의 `search` 속성을 `URLSearchParams` 클래스와 함께 사용하면 URL의 쿼리 문자열을 쉽게 다룰 수 있습니다. `Object.fromEntries()`를 활용하여 쿼리 파라미터를 JSON 객체로 변환할 수 있습니다.
- **URL 포맷팅**: `url.format()` 함수는 URL 객체를 다시 URL 문자열로 변환하는 데 사용됩니다.

### 실습: url 모듈 사용하기

**실습: /01-기본모듈/02_url_modules.js**

```js
/** (1) url 모듈과 URL 클래스 참조하기 */
import url, {URL} from 'url';

/** (2) 주소 문자열을 URL 객체로 만들기 */
const current = new URL('http://blog.hossam.kr:8765/hello/world.html?a=123&b=456#home');
console.log('href: ' 		+ current.href);
console.log('protocol: ' 	+ current.protocol);
console.log('host: ' 		+ current.host);
console.log('hostname: ' 	+ current.hostname);
console.log('port: ' 		+ current.port);
console.log('pathname: ' 	+ current.pathname);
console.log('search: ' 		+ current.search);
console.log('hash: ' 		+ current.hash);
console.log();

/** (3) 주소 문자열의 QueryString을 JSON 객체로 변환 */
const params = new URLSearchParams(current.search);
const json = Object.fromEntries(params);
console.log('JSON 객체 : %o', json);
console.log();

/** (4) JSON객체를 주소 문자열로 만들기 */
const info = {
	protocol: 'https:',
	hostname: 'blog.hossam.kr',
	port: '8080',
	pathname: '/hello/world.html',
	search: '?name=nodejs&age=10',
	hash: '#target'
}
const urlString = url.format(info);
console.log('주소 문자열 : %s', urlString);
```

---

## 3. os 모듈

`os` 모듈은 운영 체제 관련 유틸리티 메서드와 속성을 제공합니다. 이를 통해 Node.js 애플리케이션이 실행되는 시스템의 하드웨어, 운영체제 정보에 접근할 수 있습니다.

### 3.1. 시스템 기본 정보

`os` 모듈을 사용하면 홈 디렉토리, 시스템 아키텍처, 플랫폼, 임시 파일 경로, 호스트 이름 등과 같은 기본적인 시스템 정보를 조회할 수 있습니다. 또한 `os.userInfo()`를 통해 현재 사용자의 계정 정보, 홈 디렉토리, 쉘 환경 등을 확인할 수 있으며, `os.freemem()`과 `os.totalmem()`으로 시스템의 가용 메모리와 전체 메모리 용량을 파악할 수 있습니다.

**실습: /01-기본모듈/03_os_module1.js**

```js
/** (1) OS모듈 참조 */
import os from 'os';

/** (2) 시스템 기본 정보 */
console.log('홈 디렉토리 : ' + os.homedir());
console.log('시스템 아키텍처 : ' + os.arch());
console.log('os플랫폼 : ' + os.platform());
console.log('시스템 임시 디렉토리 : ' + os.tmpdir());
console.log('시스템의 hostname : %s', os.hostname());
console.log();

/** (3) 사용자 계정정보 */
var userInfo = os.userInfo();
console.log('사용자 계정명 : ' + userInfo.username);
console.log('사용자 홈 디렉토리 : ' + userInfo.homedir);
console.log('사용자 쉘 환경(Linux, Mac) : ' + userInfo.shell);
console.log();

/** (4) 메모리 용량 */
// freemem() --> 시스템에서 현재 사용 가능한 메모리 용량
// totalmem() --> 시스템의 전체 메모리 용량
console.log('시스템의 메모리 : %d(free) / %d(total)', os.freemem(), os.totalmem());
console.log();
```

### 3.2. CPU 정보

`os.cpus()` 메서드는 시스템에 장착된 각 CPU 코어에 대한 정보를 담은 객체 배열을 반환합니다. 각 객체는 CPU 모델명, 처리 속도(MHz), 그리고 `user`, `nice`, `sys`, `idle`, `irq`로 구성된 CPU 사용 시간 정보를 포함합니다. 이를 통해 시스템의 부하 분산 처리나 성능 모니터링에 필요한 데이터를 얻을 수 있습니다.

**실습: /01-기본모듈/04_os_module2.js**

```js
/** (1) OS모듈 참조 */
import os from "os";

/** (2) CPU 정보 */
const cpus = os.cpus();
console.log("CPU 코어 수 : " + cpus.length);
console.log();

cpus.forEach((v, i) => {
    console.log("[%d번째 CPU] %s", i + 1, v.model);
    console.log("처리속도: %d", v.speed);
    console.log("수행시간 정보: %j", v.times);
    console.log();
});
```

### 3.3. 네트워크 인터페이스 정보

`os.networkInterfaces()` 메서드는 시스템의 모든 네트워크 인터페이스에 대한 정보를 담은 객체를 반환합니다. 객체의 각 키는 네트워크 인터페이스의 이름(예: '이더넷', 'Wi-Fi')이며, 값은 해당 인터페이스에 할당된 네트워크 주소 정보의 배열입니다. 각 주소 정보 객체는 `family`(IPv4/IPv6), `address`(IP 주소), `mac`(MAC 주소), `netmask` 등의 속성을 포함합니다.

**실습: /01-기본모듈/05_os_module3.js**

```js
/** (1) OS모듈 참조 */
import os from "os";

/** (2) 네트워크 정보 */
const nets = os.networkInterfaces();

for (const attr in nets) {
	console.group("Network장치 이름: %s", attr);

	const item = nets[attr];

    item.forEach((v, i) => {
        console.log("주소형식: %s", v.family);
        console.log("IP주소: %s", v.address);
		console.log("맥주소: %s", v.mac);
		console.log("넷마스크: %s", v.netmask);
		console.log();
	});

    console.groupEnd();
}
```

---

## 4. myip 조회 (모듈화)

Node.js에서는 기능별로 코드를 모듈화하여 재사용성을 높이고 코드 관리를 용이하게 할 수 있습니다. `export` 키워드를 사용하여 특정 함수나 객체를 모듈로 내보낼 수 있으며, `import` 키워드를 사용하여 다른 파일에서 해당 모듈을 가져와 사용할 수 있습니다.

### 헬퍼 모듈 작성 및 활용

아래 `UtilHelper.js` 파일은 `os` 모듈을 활용하여 현재 시스템의 IP 주소를 조회하는 `myip` 함수를 정의하고 모듈로 내보냅니다. 이 함수는 `os.networkInterfaces()`를 호출하여 모든 네트워크 인터페이스를 순회하며, 그 중 `IPv4` 주소이면서 로컬 루프백 주소(`127.0.0.1`)가 아닌 IP 주소들만 찾아 배열로 반환합니다.

`06_myip.js` 파일에서는 이렇게 만들어진 `UtilHelper` 모듈을 `import`하여 `myip()` 함수를 호출하고 그 결과를 콘솔에 출력합니다. 이를 통해 복잡한 로직을 별도의 모듈로 분리하고, 사용하는 측에서는 간단하게 함수 호출만으로 원하는 기능을 수행할 수 있습니다.

### 실습: 헬퍼 모듈과 실행 파일

**실습: /helpers/UtilHelper.js**

```js
import os from "os";

const utilHelper = {
    /**
     * 현재 시스템의 IP주소를 조회하여 배열로 리턴한다.
     * @returns {Array}
     */
    myip: () => {
        const nets = os.networkInterfaces();

        return Object.values(nets)
            .flat()
            .filter(v => v.family === "IPv4" && v.address !== "127.0.0.1")
            .map(v => v.address);
    },
};

export default utilHelper;
```

**실습: /01-기본모듈/06_myip.js**

```js
import utilHelper from '../helpers/UtilHelper.js';
console.log(utilHelper.myip());
```
