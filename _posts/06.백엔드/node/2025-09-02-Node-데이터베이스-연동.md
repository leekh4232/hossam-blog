---
title: Node.js 데이터베이스 연동 (MySQL/MariaDB)
description: "Node.js 환경에서 mysql2 라이브러리를 사용하여 MySQL 또는 MariaDB 데이터베이스에 연결하고, 기본적인 CRUD 작업을 수행하는 방법을 학습합니다."
categories: [06.Backend,Node]
date:   2025-09-02 09:00:00 +0900
author: Hossam
image: /images/indexs/node1.png
tags: [Web Development,Backend,Node,Database,MySQL,MariaDB]
pin: true
math: true
mermaid: true
---

# Node.js 데이터베이스 연동 (MySQL/MariaDB)

대부분의 웹 애플리케이션은 데이터를 영구적으로 저장하고 관리하기 위해 데이터베이스를 사용합니다. Node.js는 다양한 데이터베이스와 연동할 수 있는 라이브러리들을 지원하며, 그 중에서도 MySQL 및 MariaDB는 가장 널리 사용되는 관계형 데이터베이스 관리 시스템(RDBMS)입니다.

이번 시간에는 `mysql2` 라이브러리를 사용하여 Node.js 애플리케이션에서 MariaDB 데이터베이스에 접속하고, 기본적인 데이터 처리 작업인 **CRUD(Create, Read, Update, Delete)** 를 `async/await` 구문을 통해 구현하는 방법을 학습합니다.

## 1. `mysql2` 라이브러리 설치

Node.js에서 MySQL/MariaDB와 통신하기 위해서는 전용 드라이버가 필요합니다. `mysql` 라이브러리도 있지만, `mysql2`는 Promise를 지원하여 `async/await`와 함께 사용하기 편리하고 성능이 개선된 버전이므로 `mysql2`를 사용하는 것을 권장합니다.

```bash
$ yarn add mysql2
```

## 2. 데이터베이스 접속 설정

애플리케이션에서 데이터베이스에 접속하려면 접속 정보를 설정해야 합니다.

데이터베이스 접속 정보는 보안을 위해서 설정파일에 명시하는 것이 좋습니다. 명시해야 하는 정보는 다음과 같습니다.

-  **Host**: 데이터베이스 서버의 주소 (일반적으로 `localhost`)
-  **Port**: 데이터베이스 서버의 포트 번호 (MariaDB 기본값은 `3306`, 예제에서는 `9090`)
-  **User**: 데이터베이스 사용자 계정
-  **Pass**: 사용자 계정의 비밀번호
-  **Database Name**: 접속할 데이터베이스의 이름
-  **Connection Limit**: 커넥션 풀의 최대 연결 수 (예: `10`)

`/.env` 파일에 다음과 같이 접속 정보를 설정합니다.

```env
# ... 이전 내용 생략 ...

# 데이터베이스 접속 정보
DB_HOST=localhost
DB_PORT=9090
DB_USER=myschool
DB_PASS=1234
DB_NAME=myschool
DB_CONNECTION_LIMIT=10
```

## 3. 데이터베이스 커넥션 풀(Connection Pool)

사용자의 요청이 있을 때마다 데이터베이스에 새로 연결하고 해제하는 작업은 많은 비용을 발생시킵니다. 이를 방지하기 위해 **커넥션 풀(Connection Pool)** 방식을 사용합니다.

커넥션 풀은 미리 일정 개수의 데이터베이스 연결(Connection)을 만들어 두고, 필요할 때마다 가져다 쓴 뒤 다시 반납하는 방식입니다. 이를 통해 애플리케이션의 성능을 크게 향상시킬 수 있습니다.

`mysql2` 라이브러리는 커넥션 풀 기능을 쉽게 구현할 수 있도록 `promise()` 메서드를 제공합니다.

### DBHelper 클래스 API 명세

구현할 `DBHelper` 클래스의 주요 기능과 메서드를 다음 표와 같이 정의합니다:

| **구분** | **메서드/속성** | **타입** | **매개변수** | **반환값** | **설명** |
|----------|----------------|----------|-------------|------------|----------|
| **속성** | `connected` | getter | - | `boolean` | 데이터베이스 연결 상태 확인 |
| **연결 관리** | `connect()` | async method | - | `Promise<void>` | 커넥션 풀 생성 및 데이터베이스 연결 |
| | `close()` | async method | - | `Promise<void>` | 커넥션 풀 종료 및 연결 해제 |
| **쿼리 실행** | `query()` | async method | `sql: string`<br>`params?: array` | `Promise<array\|object>` | SQL 쿼리 실행 및 결과 반환 |
| **트랜잭션** | `transaction()` | async method | `callback: function` | `Promise<any>` | 트랜잭션 내에서 안전한 쿼리 실행 |

### 주요 특징

- **싱글톤 패턴**: 애플리케이션 전체에서 하나의 인스턴스만 유지
- **클래스 기반**: 상태 관리와 메서드 체계화를 통한 명확한 구조
- **환경변수 지원**: `.env` 파일을 통한 안전한 설정 관리
- **에러 처리**: 상세한 로깅과 예외 처리
- **성능 최적화**: 커넥션 풀을 통한 효율적인 DB 연결 관리

### 실습: 데이터베이스 접속 모듈 생성 (`/helpers/DBHelper.js`)

반복적인 데이터베이스 접속 코드를 줄이고 재사용성을 높이기 위해, 향상된 `DBHelper` 모듈을 생성합니다.

```javascript
// 필요한 라이브러리 import
import dotenv from 'dotenv';           // 환경변수 관리를 위한 라이브러리
import mysql from 'mysql2/promise';   // MySQL/MariaDB 연결을 위한 Promise 기반 드라이버
import logger from './LogHelper.js';  // 사용자 정의 로깅 헬퍼

// .env 파일의 환경변수를 process.env에 로드
// 이 함수 호출 후 process.env.DB_HOST, process.env.DB_PORT 등을 사용할 수 있음
dotenv.config();

class DBHelper {
    /**
     * 생성자 - 클래스 인스턴스 초기화
     */
    constructor() {
        this.pool = null;           // MySQL 커넥션 풀 객체
        this.isConnected = false;   // 데이터베이스 연결 상태 플래그
    }

    /**
     * 데이터베이스 연결 상태를 확인하는 getter 속성
     * @returns {boolean} 연결되어 있으면 true, 아니면 false
     */
    get connected() {
        return this.isConnected && this.pool !== null;
    }

    /**
     * 커넥션 풀을 생성하고 데이터베이스에 접속
     *
     * 커넥션 풀의 장점:
     * - 연결 재사용으로 성능 향상
     * - 동시 접속 수 제어로 서버 안정성 확보
     * - 자동 연결 관리로 개발 편의성 증대
     */
    async connect() {
        // 이미 연결되어 있다면 재연결하지 않음 (중복 연결 방지)
        if (this.connected) {
            logger.debug('Database already connected');
            return;
        }

        logger.debug('----------- DATABASE Connect -----------');

        try {
            // 커넥션 풀 생성 - 환경변수에서 설정값 읽어옴
            this.pool = mysql.createPool({
                host: process.env.DB_HOST,                                         // 데이터베이스 서버 주소
                port: parseInt(process.env.DB_PORT) || 3306,                      // 포트 번호 (기본값: 3306)
                user: process.env.DB_USER,                                        // 사용자 계정
                password: process.env.DB_PASS,                                    // 비밀번호
                database: process.env.DB_NAME,                                    // 데이터베이스 이름
                connectionLimit: parseInt(process.env.DB_CONNECTION_LIMIT) || 10, // 최대 연결 수 (기본값: 10)
                waitForConnections: true,                                         // 연결 대기 여부
                queueLimit: 0                                                     // 대기 큐 제한 (0 = 무제한)
            });

            // 연결 테스트 - 실제 데이터베이스에 ping을 보내 연결 확인
            const connection = await this.pool.getConnection();  // 풀에서 연결 객체 가져오기
            await connection.ping();                             // 연결 상태 확인
            connection.release();                                // 연결 객체를 풀에 반납

            // 연결 성공 상태 업데이트
            this.isConnected = true;
            logger.info('Database connected successfully');

        } catch (error) {
            // 연결 실패 시 에러 처리
            logger.error('Database connection failed:', error);
            this.isConnected = false;
            throw error;  // 상위 레벨로 에러 전파
        }
    }

    /**
     * 커넥션 풀을 종료하고 모든 연결을 해제
     * 애플리케이션 종료 시 반드시 호출해야 함
     */
    async close() {
        if (this.pool) {
            try {
                await this.pool.end();      // 모든 연결 종료 대기
                this.pool = null;           // 풀 객체 초기화
                this.isConnected = false;   // 연결 상태 플래그 업데이트
                logger.info('Database connection closed');
            } catch (error) {
                logger.error('Error closing database connection:', error);
            }
        }
    }

    /**
     * SQL문을 실행하고 결과를 반환
     *
     * @param {string} sql - 실행할 SQL문 (? 플레이스홀더 사용 가능)
     * @param {array} params - SQL문의 ? 자리에 들어갈 파라미터 배열
     * @returns {Promise<array|object>} SELECT 결과는 배열, INSERT/UPDATE/DELETE는 OkPacket 객체
     */
    async query(sql, params = []) {
        // 연결 상태 확인
        if (!this.connected) {
            throw new Error('Database not connected. Call connect() first.');
        }

        let dbcon = null;   // 커넥션 객체
        let result = null;  // 쿼리 실행 결과

        try {
            // 커넥션 풀에서 사용 가능한 연결 객체 임대
            dbcon = await this.pool.getConnection();

            // 성능 측정을 위한 시작 시간 기록
            const startTime = Date.now();
            logger.debug(`Executing SQL: ${sql.trim()}`);

            // SQL 실행 - 파라미터 바인딩으로 SQL Injection 방지
            const [rows] = await dbcon.query(sql, params);

            // 실행 시간 계산 및 로깅
            const executionTime = Date.now() - startTime;
            logger.debug(`SQL executed in ${executionTime}ms`);

            // 결과 타입에 따른 처리 분기
            // OkPacket: INSERT, UPDATE, DELETE 작업의 결과 객체
            if (rows.constructor.name === 'OkPacket') {
                result = {
                    fieldCount: rows.fieldCount,       // 필드 개수
                    affectedRows: rows.affectedRows,   // 영향받은 행 수
                    insertId: rows.insertId,           // INSERT 시 생성된 ID
                    serverStatus: rows.serverStatus,   // 서버 상태
                    warningCount: rows.warningCount,   // 경고 개수
                    message: rows.message,             // 서버 메시지
                    protocol41: rows.protocol41,       // 프로토콜 버전
                    changedRows: rows.changedRows,     // 실제 변경된 행 수
                };
            } else {
                // SELECT 결과는 배열 형태로 반환
                result = rows;
            }

        } catch (err) {
            // SQL 실행 에러 로깅 및 재발생
            logger.error('SQL execution error:', { sql, params, error: err.message });
            throw err;
        } finally {
            // 연결 객체를 반드시 풀에 반납 (메모리 누수 방지)
            if (dbcon) {
                dbcon.release();
            }
        }

        return result;
    }

    /**
     * 트랜잭션 내에서 여러 쿼리를 안전하게 실행
     *
     * 트랜잭션의 ACID 특성:
     * - Atomicity(원자성): 모든 작업이 성공하거나 모두 실패
     * - Consistency(일관성): 데이터베이스 제약조건 유지
     * - Isolation(격리성): 동시 실행되는 트랜잭션 간 간섭 방지
     * - Durability(지속성): 커밋된 데이터는 영구적으로 저장
     *
     * @param {function} callback - 트랜잭션 내에서 실행할 함수
     * @returns {Promise<any>} 콜백 함수의 반환값
     */
    async transaction(callback) {
        // 연결 상태 확인
        if (!this.connected) {
            throw new Error('Database not connected. Call connect() first.');
        }

        let dbcon = null;

        try {
            // 트랜잭션 전용 연결 객체 획득
            dbcon = await this.pool.getConnection();

            // 트랜잭션 시작
            await dbcon.beginTransaction();
            logger.debug('Transaction started');

            // 사용자 정의 쿼리들 실행
            const result = await callback(dbcon);

            // 모든 작업이 성공하면 커밋
            await dbcon.commit();
            logger.debug('Transaction committed');

            return result;
        } catch (error) {
            // 에러 발생 시 롤백 (모든 변경사항 취소)
            if (dbcon) {
                await dbcon.rollback();
                logger.debug('Transaction rolled back');
            }
            logger.error('Transaction error:', error);
            throw error;
        } finally {
            // 트랜잭션 전용 연결 객체 반납
            if (dbcon) {
                dbcon.release();
            }
        }
    }
}

// 싱글톤 패턴 구현 - 애플리케이션 전체에서 하나의 인스턴스만 사용
const dbHelper = new DBHelper();
export default dbHelper;
```

## 4. CRUD 구현하기

이제 `DBHelper` 모듈을 사용하여 `myschool` 데이터베이스의 `departments` 테이블에 대한 CRUD 작업을 수행하는 예제를 만들어 보겠습니다.

### 1) DBHelper 기본 사용법 및 조회 (SELECT)

`DBHelper`의 기본 사용법과 데이터 조회 기능을 학습합니다. 연결 상태 확인, 기본 쿼리, 파라미터 쿼리, 트랜잭션을 포함합니다.

**실습: `/07-Database/01_dbhelper_example.js`**

```javascript
import DBHelper from '../helpers/DBHelper.js';

(async () => {
    try {
        // 1. 데이터베이스 연결
        console.log('1. 데이터베이스 연결...');
        await DBHelper.connect();

        // 2. 연결 상태 확인
        console.log(`2. 연결 상태: ${DBHelper.connected ? '연결됨' : '연결 안됨'}`);

        // 3. 기본 쿼리 실행
        console.log('\n3. 기본 쿼리 실행...');
        const sql = "SELECT id, dname, loc FROM departments LIMIT 3";
        const result = await DBHelper.query(sql);
        console.log('결과:', result);

        // 4. 파라미터를 사용한 쿼리
        console.log('\n4. 파라미터 쿼리 실행...');
        const paramSql = "SELECT * FROM departments WHERE id = ?";
        const paramResult = await DBHelper.query(paramSql, [101]);
        console.log('파라미터 결과:', paramResult);

        // 5. 트랜잭션 예제
        console.log('\n5. 트랜잭션 예제...');
        const transactionResult = await DBHelper.transaction(async (connection) => {
            // 트랜잭션 내에서 여러 쿼리 실행
            const [rows1] = await connection.query("SELECT COUNT(*) as count FROM departments");
            const [rows2] = await connection.query("SELECT COUNT(*) as count FROM students");

            return {
                departments: rows1[0].count,
                students: rows2[0].count
            };
        });
        console.log('트랜잭션 결과:', transactionResult);

    } catch (e) {
        console.error("데이터베이스 작업에 실패했습니다:");
        console.error(e.message);
    } finally {
        // DB 접속 해제
        console.log('\n6. 데이터베이스 연결 종료...');
        await DBHelper.close();
        console.log('연결이 종료되었습니다.');
    }
})();
```

### 2) 데이터 추가 (INSERT)

`INSERT` 문을 사용하여 새로운 데이터를 추가합니다. 단일 레코드 삽입과 배치 삽입, 트랜잭션을 활용한 안전한 삽입을 다룹니다.

**실습: `/07-Database/02_insert_example.js`**

```javascript
import DBHelper from '../helpers/DBHelper.js';

(async () => {
    try {
        console.log('=== DBHelper INSERT 예제 ===\n');
        await DBHelper.connect();

        // 1. 단일 레코드 INSERT
        console.log('1. 단일 학과 정보 INSERT...');
        const insertSql = `
            INSERT INTO departments (id, dname, loc, phone, email, established, homepage)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        `;

        const newDeptData = [
            600,
            '데이터사이언스학과',
            'IT관',
            '051-999-8888',
            'ds@myschool.ac.kr',
            2023,
            'http://ds.myschool.ac.kr'
        ];

        const insertResult = await DBHelper.query(insertSql, newDeptData);
        console.log('INSERT 결과:', insertResult);
        console.log(`새로 생성된 레코드 ID: ${insertResult.insertId}`);
        console.log(`영향받은 행 수: ${insertResult.affectedRows}\n`);

        // 2. 배치 INSERT (여러 레코드 동시 삽입)
        console.log('2. 여러 학과 정보 배치 INSERT...');
        const batchInsertSql = `
            INSERT INTO departments (id, dname, loc, phone, email, established, homepage)
            VALUES
                (?, ?, ?, ?, ?, ?, ?),
                (?, ?, ?, ?, ?, ?, ?),
                (?, ?, ?, ?, ?, ?, ?)
        `;

        const batchData = [
            601, '융합소프트웨어학과', 'IT관', '051-999-8801', 'sw@myschool.ac.kr', 2024, 'http://sw.myschool.ac.kr',
            602, '사이버보안학과', 'IT관', '051-999-8802', 'security@myschool.ac.kr', 2024, 'http://security.myschool.ac.kr',
            603, '게임개발학과', 'IT관', '051-999-8803', 'game@myschool.ac.kr', 2024, 'http://game.myschool.ac.kr'
        ];

        const batchResult = await DBHelper.query(batchInsertSql, batchData);
        console.log('배치 INSERT 결과:', batchResult);

        // 3. 트랜잭션을 활용한 안전한 INSERT
        console.log('\n3. 트랜잭션 INSERT...');
        const transactionResult = await DBHelper.transaction(async (connection) => {
            // 트랜잭션 내에서 여러 INSERT 실행
            const [result1] = await connection.query(
                'INSERT INTO departments (id, dname, loc) VALUES (?, ?, ?)',
                [604, '트랜잭션테스트학과1', 'IT관']
            );

            const [result2] = await connection.query(
                'INSERT INTO departments (id, dname, loc) VALUES (?, ?, ?)',
                [605, '트랜잭션테스트학과2', 'IT관']
            );

            return {
                firstInsert: result1.insertId,
                secondInsert: result2.insertId
            };
        });
        console.log('트랜잭션 INSERT 결과:', transactionResult);

    } catch (e) {
        console.error("INSERT 작업에 실패했습니다:");
        console.error(e.message);
    } finally {
        await DBHelper.close();
    }
})();
```

### 3) 데이터 수정 (UPDATE)

`UPDATE` 문을 사용하여 기존 데이터를 수정합니다. 단일 레코드 수정, 조건부 다중 레코드 수정, 트랜잭션을 활용한 안전한 수정을 다룹니다.

**실습: `/07-Database/03_update_example.js`**

```javascript
import DBHelper from '../helpers/DBHelper.js';

(async () => {
    try {
        console.log('=== DBHelper UPDATE 예제 ===\n');
        await DBHelper.connect();

        // 1. 단일 레코드 UPDATE
        console.log('1. 특정 학과 정보 UPDATE...');

        // 먼저 현재 데이터 확인
        const beforeUpdateSql = 'SELECT id, dname, loc, phone FROM departments WHERE id = ?';
        const beforeData = await DBHelper.query(beforeUpdateSql, [101]);
        console.log('수정 전 데이터:', beforeData[0]);

        // 업데이트 실행
        const updateSql = `
            UPDATE departments
            SET loc = ?, phone = ?, homepage = ?
            WHERE id = ?
        `;
        const updateData = ['신공학관', '051-123-9999', 'http://newcs.myschool.ac.kr', 101];

        const updateResult = await DBHelper.query(updateSql, updateData);
        console.log('UPDATE 결과:', updateResult);
        console.log(`영향받은 행 수: ${updateResult.affectedRows}\n`);

        // 수정 후 데이터 확인
        const afterData = await DBHelper.query(beforeUpdateSql, [101]);
        console.log('수정 후 데이터:', afterData[0]);

        // 2. 조건부 다중 레코드 UPDATE
        console.log('\n2. 조건부 다중 레코드 UPDATE...');
        const multiUpdateSql = `
            UPDATE departments
            SET phone = CONCAT('051-555-', LPAD(id, 4, '0'))
            WHERE loc LIKE '%공학관%'
        `;

        const multiUpdateResult = await DBHelper.query(multiUpdateSql);
        console.log('다중 UPDATE 결과:', multiUpdateResult);

        // 3. 트랜잭션을 활용한 안전한 UPDATE
        console.log('\n3. 트랜잭션 UPDATE...');
        const transactionResult = await DBHelper.transaction(async (connection) => {
            // 여러 테이블을 동시에 업데이트하는 예제
            const [updateResult1] = await connection.query(
                'UPDATE departments SET homepage = ? WHERE id = ?',
                ['http://updated.myschool.ac.kr', 102]
            );

            const [updateResult2] = await connection.query(
                'UPDATE departments SET established = ? WHERE id = ?',
                [2025, 102]
            );

            return {
                homepageUpdate: updateResult1.affectedRows,
                establishedUpdate: updateResult2.affectedRows
            };
        });
        console.log('트랜잭션 UPDATE 결과:', transactionResult);

    } catch (e) {
        console.error("UPDATE 작업에 실패했습니다:");
        console.error(e.message);
    } finally {
        await DBHelper.close();
    }
})();
```

### 4) 데이터 삭제 (DELETE)

`DELETE` 문을 사용하여 데이터를 삭제합니다. 단일 레코드 삭제, 조건부 다중 삭제, 안전한 삭제 방법을 다룹니다.

**실습: `/07-Database/04_delete_example.js`**

```javascript
import DBHelper from '../helpers/DBHelper.js';

(async () => {
    try {
        console.log('=== DBHelper DELETE 예제 ===\n');
        await DBHelper.connect();

        // 0. 삭제할 테스트 데이터 먼저 생성
        console.log('0. 테스트용 데이터 생성...');
        const testDataSql = `
            INSERT INTO departments (id, dname, loc, phone, email, established, homepage)
            VALUES
                (700, '테스트학과1', '테스트관', '051-000-0001', 'test1@test.com', 2024, 'http://test1.com'),
                (701, '테스트학과2', '테스트관', '051-000-0002', 'test2@test.com', 2024, 'http://test2.com'),
                (702, '테스트학과3', '테스트관', '051-000-0003', 'test3@test.com', 2024, 'http://test3.com'),
                (703, '임시학과', '임시관', '051-000-0004', 'temp@test.com', 2024, 'http://temp.com')
            ON DUPLICATE KEY UPDATE dname = VALUES(dname)
        `;

        await DBHelper.query(testDataSql);
        console.log('테스트 데이터가 생성되었습니다.\n');

        // 1. 단일 레코드 DELETE
        console.log('1. 특정 학과 DELETE...');
        const deleteSql = 'DELETE FROM departments WHERE id = ?';
        const deleteResult = await DBHelper.query(deleteSql, [700]);

        console.log('DELETE 결과:', deleteResult);
        console.log(`삭제된 행 수: ${deleteResult.affectedRows}\n`);

        // 2. 조건부 다중 레코드 DELETE
        console.log('2. 조건부 다중 레코드 DELETE...');
        const multiDeleteSql = 'DELETE FROM departments WHERE loc = ?';
        const multiDeleteResult = await DBHelper.query(multiDeleteSql, ['테스트관']);

        console.log('다중 DELETE 결과:', multiDeleteResult);

        // 3. 트랜잭션을 활용한 안전한 DELETE
        console.log('\n3. 트랜잭션 DELETE...');
        const transactionResult = await DBHelper.transaction(async (connection) => {
            // 관련 데이터 먼저 확인 후 삭제
            const [checkResult] = await connection.query(
                'SELECT COUNT(*) as count FROM departments WHERE id = ?', [703]
            );

            if (checkResult[0].count > 0) {
                const [deleteResult] = await connection.query(
                    'DELETE FROM departments WHERE id = ?', [703]
                );
                return { deleted: true, affectedRows: deleteResult.affectedRows };
            } else {
                return { deleted: false, message: '삭제할 데이터가 없습니다.' };
            }
        });
        console.log('트랜잭션 DELETE 결과:', transactionResult);

    } catch (e) {
        console.error("DELETE 작업에 실패했습니다:");
        console.error(e.message);
    } finally {
        await DBHelper.close();
    }
})();
```

---

## 5. 주요 학습 포인트

### DBHelper 클래스의 핵심 특징

1. **싱글톤 패턴**: 애플리케이션 전체에서 하나의 DB 연결 인스턴스만 유지
2. **클래스 기반 구조**: 상태 관리와 메서드 체계화로 더 나은 코드 구조
3. **async/await 지원**: 모든 DB 작업이 비동기로 처리되어 성능 향상
4. **트랜잭션 지원**: 여러 쿼리를 하나의 단위로 안전하게 처리
5. **환경변수 활용**: `.env` 파일을 통한 안전한 설정 관리
