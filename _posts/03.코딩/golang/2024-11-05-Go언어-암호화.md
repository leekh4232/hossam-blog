---
title: "Go μ–Έμ–΄ μ•”νΈν™”: λ””μ§€ν„Έ μ„λ…κ³Ό κ²€μ¦"
description: "Go μ–Έμ–΄μ crypto ν¨ν‚¤μ§€λ¥Ό μ‚¬μ©ν•μ—¬ Web3μ ν•µμ‹¬μΈ λ””μ§€ν„Έ μ„λ…κ³Ό κ²€μ¦ μ›λ¦¬λ¥Ό Javaμ™€ λΉ„κµν•λ©° μ•μ•„λ΄„."
categories: [03.Coding,Golang]
date:   2024-11-05 10:00:00 +0900
author: Hossam
image: /images/indexs/golang.webp
tags: [Programming,Golang,Coding,Crypto,Web3]
pin: false
math: true
mermaid: true
---

# Go μ–Έμ–΄ μ•”νΈν™”: λ””μ§€ν„Έ μ„λ…κ³Ό κ²€μ¦

λΈ”λ΅μ²΄μΈμ΄λ‚ Web3 μ„Έκ³„μ—μ„ κ°€μ¥ μ¤‘μ”ν• κ±΄ **β€λ‚΄ μμ‚°μ΄ λ‚΄ κ²ƒμ„μ„ μ¦λ…ν•λ” κ²ƒβ€**

μ΄λ¥Ό κ°€λ¥ν•κ² ν•΄μ£Όλ” ν•µμ‹¬ κΈ°μ μ΄ λ°”λ΅ λ””μ§€ν„Έ μ„λ…(Digital Signature)μ„.

μ‰½κ² λ§ν•΄,

- βοΈ κ°μΈν‚¤(Private Key) β†’ λ‚λ§ κ°€μ§„ λ„μ¥ (λΉ„λ°€ λ„μ¥)
- π“Ά κ³µκ°ν‚¤(Public Key) β†’ λ¨λ‘μ—κ² μ•λ ¤μ§„ λ„μ¥ λ„κ° (λ„μ¥μ μ§„μ§ μ—¬λ¶€ ν™•μΈ)

λ‚΄κ°€ λ„μ¥(κ°μΈν‚¤)μΌλ΅ μ°μ€ λ¬Έμ„λ”, λ„κµ¬λ“  κ³µκ°ν‚¤λ¥Ό λ³΄κ³  β€μ•„! μ΄κ±΄ μ§„μ§ μ£ΌμΈμ΄ μ°μ€ κ±°κµ¬λ‚β€ ν•κ³  ν™•μΈν•  μ μμ.

## 1. λ””μ§€ν„Έ μ„λ…κ³Ό Javaμ μ•”νΈν™” λΉ„κµ

λ””μ§€ν„Έ μ„λ…μ€ **λΉ„λ€μΉ­ ν‚¤ μ•”νΈν™”**μ— κΈ°λ°ν•¨. **κ°μΈν‚¤**λ΅ λ°μ΄ν„°μ— μ„λ…ν•λ©΄, μμ΄ λλ” **κ³µκ°ν‚¤**λ¥Ό κ°€μ§„ λ„κµ¬λ‚ κ·Έ μ„λ…μ„ κ²€μ¦ν•  μ μμ. κ°μΈν‚¤λ” μ†μ μλ§ μ•μ „ν•κ² λ³΄κ΄€ν•κ³ , κ³µκ°ν‚¤λ” μ™Έλ¶€μ— μ•λ ¤λ„ μ•μ „ν•¨.

Goμ™€ Javaλ” λ¨λ‘ κ°•λ ¥ν• μ•”νΈν™” λΌμ΄λΈλ¬λ¦¬λ¥Ό λ‚΄μ¥ν•κ³  μμ§€λ§, μ‚¬μ© λ°©μ‹κ³Ό μ² ν•™μ—μ„ μ°¨μ΄κ°€ μμ.

| ν•­λ© | Go (`crypto` ν¨ν‚¤μ§€) | Java (`java.security`, `javax.crypto`) |
|---|---|---|
| **μ² ν•™** | λ‹¨μν•κ³  μ§κ΄€μ , μ§μ ‘ μ΅°λ¦½ν•΄μ„ μ‚¬μ© | ν¬λ°©λ€ν•κ³  μ„¤μ •μ΄ λ§μ, Provider λ¨λΈ μ‚¬μ© |
| **μ£Όμ” μ•κ³ λ¦¬μ¦** | ECDSA, RSA, SHA256 | EC, RSA, SHA256 |
| **μ‚¬μ© νΈμμ„±** | μ½”λ“κ°€ μ§§κ³  μ§κ΄€μ  | μƒλ€μ μΌλ΅ λ³µμ΅ν•κ³  μ¥ν™©ν•¨ |

Goλ” "λ κ³  λΈ”λ΅"μ²λΌ ν•„μ”ν• κΈ°λ¥λ§ λ”±λ”± κΊΌλ‚΄ μ“°λ” λλ‚μΈ λ°λ©΄, Javaλ” "μΆ…ν•© κ³µκµ¬ν•¨"μ²λΌ λ‹¤μ–‘ν• λ„κµ¬κ°€ μμ§€λ§ μ΅°λ¦½λ²•μ΄ λ³µμ΅ν•¨

## 2. λ””μ§€ν„Έ μ„λ… νλ¦„ μ΄ν•΄ν•κΈ°

- λ©”μ‹μ§€ β†’ SHA-256 ν•΄μ‹λ΅ μ”μ•½ (μ§€λ¬Έ λ§λ“¤κΈ°)
- κ°μΈν‚¤ β†’ μ§€λ¬Έμ— λ„μ¥ μ°κΈ° (μ„λ… μƒμ„±)
- κ³µκ°ν‚¤ β†’ λ„μ¥μ΄ μ§„μ§μΈμ§€ ν™•μΈ (κ²€μ¦)

```mermaid
graph LR
    A[λ©”μ‹μ§€] --> B[SHA-256 ν•΄μ‹]
    B --> C[κ°μΈν‚¤λ΅ μ„λ…]
    C --> D[λ””μ§€ν„Έ μ„λ…]

    B --> E[κ³µκ°ν‚¤ κ²€μ¦]
    D --> E
    E --> F{μ„λ… μ ν¨ μ—¬λ¶€}
```

## 2. λ””μ§€ν„Έ μ„λ…μ— ν•„μ”ν• Go ν¨ν‚¤μ§€

λ””μ§€ν„Έ μ„λ…μ„ κµ¬ν„ν•κΈ° μ„ν•΄ Goμ ν‘μ¤€ λΌμ΄λΈλ¬λ¦¬μ μ—¬λ¬ `crypto` κ΄€λ ¨ ν¨ν‚¤μ§€λ¥Ό μ΅°ν•©ν•΄μ•Ό ν•¨.

-   `crypto/ecdsa`: **νƒ€μ› κ³΅μ„  λ””μ§€ν„Έ μ„λ… μ•κ³ λ¦¬μ¦(ECDSA)**. ν‚¤ μƒμ„±, μ„λ…, κ²€μ¦μ ν•µμ‹¬ μ—­ν• μ„ ν•¨.
-   `crypto/elliptic`: κ³΅μ„ ν•¨μλ“¤μ„ μ κ³µν•¨
-   `crypto/sha256`: **SHA-256 ν•΄μ‹ μ•κ³ λ¦¬μ¦**. μ›λ³Έ λ°μ΄ν„°λ¥Ό κ³ μ • κΈΈμ΄μ ν•΄μ‹κ°’μΌλ΅ λ³€ν™ν•μ—¬ λ°μ΄ν„°μ λ¬΄κ²°μ„±μ„ λ³΄μ¥ν•¨.
-   `crypto/rand`: **μ•”νΈν•™μ  λ‚μ μƒμ„±κΈ°**. μ•μ „ν• ν‚¤μ™€ μ„λ…μ„ μƒμ„±ν•λ” λ° ν•„μμ μΈ λ¬΄μ‘μ„μ„±μ„ μ κ³µν•¨.

### κ³΅μ„ ν•¨μ μ ν•

μ‰½κ² λ§ν•λ©΄ **μ•”νΈν™”μ— μ‚¬μ©ν•  μ΄λ™μ¥(κ³΅μ„ μ μν•™μ  κ³µκ°„)**μ„ μ§€μ •ν•λ” κ²ƒμ΄λΌκ³  μƒκ°ν•λ©΄ λ¨.

κ·Έ μ΄λ™μ¥ μ„μ—μ„ κ°μΈν‚¤μ™€ κ³µκ°ν‚¤κ°€ λ§λ“¤μ–΄μ§€κ³ , μ„λ…κ³Ό κ²€μ¦μ΄ μ΄λ£¨μ–΄μ§.

| ν•¨μ | μ„¤λ… | λ³΄μ• μμ¤€ |
|---|---|---|
| elliptic.P224() | 224λΉ„νΈ κ³΅μ„  | λΉ„κµμ  μ•½ν•¨ (μ”μ¦μ€ μ μ• μ”€) |
| elliptic.P256() | 256λΉ„νΈ κ³΅μ„  | κ°€μ¥ λ„λ¦¬ μ“°μ„ (TLS, λΈ”λ΅μ²΄μΈ κΈ°λ³Έ) |
| elliptic.P384() | 384λΉ„νΈ κ³΅μ„  | λ” κ°•λ ¥ν• λ³΄μ• ν•„μ” μ‹ |
| elliptic.P521() | 521λΉ„νΈ κ³΅μ„  | μµμƒμ„ λ³΄μ•, ν•μ§€λ§ μ—°μ‚° λλ¦Ό |

## 3. μ‹¤μµ: λ””μ§€ν„Έ μ„λ… μƒμ„± λ° κ²€μ¦

λ‹¤μ μ‹¤μµμ„ ν†µν•΄ λ””μ§€ν„Έ μ„λ…μ μ „μ²΄ κ³Όμ •μ„ μ§μ ‘ μ²΄ν—ν•΄ λ³΄μ.

1.  **ν‚¤ μƒμ„±**: ECDSA κ°μΈν‚¤μ™€ κ³µκ°ν‚¤ μμ„ λ§λ“¦.
2.  **λ©”μ‹μ§€ ν•΄μ‹±**: μ„λ…ν•  λ©”μ‹μ§€μ SHA-256 ν•΄μ‹λ¥Ό κ³„μ‚°ν•¨.
3.  **μ„λ…**: κ°μΈν‚¤λ¥Ό μ‚¬μ©ν•΄ λ©”μ‹μ§€ ν•΄μ‹μ— μ„λ…ν•¨.
4.  **κ²€μ¦**: κ³µκ°ν‚¤λ¥Ό μ‚¬μ©ν•΄ μ„λ…μ΄ μ ν¨ν•μ§€ ν™•μΈν•¨.

**μ‹¤μµ νμΌ: `14-μ•”νΈν™”/main.go`**
```go
package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"log"
)

func main() {
	// 1. ν‚¤ μƒμ„±
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		log.Fatal(err)
	}
	publicKey := &privateKey.PublicKey

	// ν‚¤ μ¶λ ¥
	fmt.Println("Private Key:", privateKey)
	fmt.Println("Public Key:", publicKey)

	// 2. λ©”μ‹μ§€ μ¤€λΉ„ λ° ν•΄μ‹
	message := []byte("hello world")
	hash := sha256.Sum256(message)
	fmt.Println("λ©”μ‹μ§€ ν•΄μ‹:", hash)

	// 3. μ„λ… μƒμ„±
	signature, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("μ„λ…:", signature)

	// 4. κ²€μ¦
	valid := ecdsa.VerifyASN1(publicKey, hash[:], signature)
	if valid {
		fmt.Println(">>> μ„λ… κ²€μ¦ μ„±κ³µ!")
		fmt.Println(">>> μ›λ¬Έ λ©”μ‹μ§€:", string(message))
	} else {
		fmt.Println(">>> μ„λ… κ²€μ¦ μ‹¤ν¨!")
	}

	// 5. λ³€μ΅°λ λ©”μ‹μ§€ ν…μ¤νΈ
	fakeMessage := []byte("hello gopher")
	fakeHash := sha256.Sum256(fakeMessage)
	fakeValid := ecdsa.VerifyASN1(publicKey, fakeHash[:], signature)
	fmt.Printf(">>> λ³€μ΅° λ©”μ‹μ§€ κ²€μ¦ κ²°κ³Ό: %v\n", fakeValid)
}
```

### μ‹¤ν–‰ κ²°κ³Ό

```text
Private Key: ... μ‹¤ν–‰μ‹λ§λ‹¤ λ°”λ€ ...
Public Key: ... μ‹¤ν–‰μ‹λ§λ‹¤ λ°”λ€ ....
λ©”μ‹μ§€ ν•΄μ‹: ... μ‹¤ν–‰μ‹λ§λ‹¤ λ°”λ€ ...
μ„λ…: ... μ‹¤ν–‰μ‹λ§λ‹¤ λ°”λ€ ...
>>> μ„λ… κ²€μ¦ μ„±κ³µ!
>>> μ›λ¬Έ λ©”μ‹μ§€: hello world
>>> λ³€μ΅° λ©”μ‹μ§€ κ²€μ¦ κ²°κ³Ό: false
```

μ΄ μ‹¤μµμ„ ν†µν•΄ κ°μΈν‚¤μ μ†μ μλ§μ΄ νΉμ • λ°μ΄ν„°μ— λ€ν• μ ν¨ν• μ„λ…μ„ μƒμ„±ν•  μ μμΌλ©°, κ³µκ°ν‚¤λ¥Ό κ°€μ§„ λ„κµ¬λ‚ κ·Έ μ„λ…μ„ κ²€μ¦ν•  μ μμμ„ ν™•μΈν•¨. μ΄κ²ƒμ΄ λ°”λ΅ λΈ”λ΅μ²΄μΈμ—μ„ κ±°λμ μ†μ κ¶μ„ μ¦λ…ν•κ³  μ‹ λΆ°λ¥Ό κµ¬μ¶•ν•λ” ν•µμ‹¬ μ›λ¦¬μ„.
